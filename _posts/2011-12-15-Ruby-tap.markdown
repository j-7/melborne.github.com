---
layout: post
title: Rubyのtapはメソッドチェーンだけのものじゃない!
date: 2011-12-15
comments: true
categories:
---

##Rubyのtapはメソッドチェーンだけのものじゃない!
あるインスタンス変数にオブジェクトがセットされているときに
その参照を外しつつ
そのオブジェクトを返すというメソッドが必要になったんだよ
次のような感じだよ
{% highlight ruby %}
 @name = nil #at initialize
 def set_name(name)
   @name = name
 end
 def reset_name
 end
 set_name('Charlie') # => "Charlie"
 reset_name # => "Charlie"
{% endhighlight %}

ここでreset_nameしたときに
インスタンス変数にセットされてた
オブジェクトを返したいんだ
なんかよくありそうだよね

こんなときは普通reset_nameを
次のように書くと思うんだ
{% highlight ruby %}
 def reset_name
   name = @name
   @name = nil
   name
 end
 set_name('Charlie') # => "Charlie"
 reset_name # => "Charlie"
{% endhighlight %}

でもなんかスマートじゃないよね

で少し考えたんだけど
多重代入を使うともう少しマシになるんだ
{% highlight ruby %}
 def reset_name
   name, @name = @name, nil
   name
 end
 set_name('Charlie') # => "Charlie"
 reset_name # => "Charlie"
{% endhighlight %}

でもやっぱり返り値を確保するためだけに
ローカル変数を用意しなきゃならないなんて
なんかイケてないよね..

そこでObject#tapの出番ですよ奥さん..
{% highlight ruby %}
 def reset_name
   @name.tap { @name = nil }
 end
 set_name('Charlie') # => "Charlie"
 reset_name # => "Charlie"
 @name # => nil
{% endhighlight %}

tapはそのブロックを評価するけれども
その結果を捨ててしまうという
謙虚な変わり者のメソッドだよ

なかなかイケてると思うんだけど
どうかな？
周知のTipsだったらごめんね

##Rubyのエニュメレータ内での破壊行為は止めてください!
RubyのArrayにはrotate!という便利なメソッドがあるよ
このメソッドは文字通り配列の要素をローテートするんだ
{% highlight ruby %}
 a = [1,2,3]
 a.rotate! # => [2, 3, 1]
 a.rotate! # => [3, 1, 2]
 a # => [3, 1, 2]
{% endhighlight %}
メソッド名の最後に!(ビックリマーク)があるから
これは元のオブジェクト自身を変えるよ

昨日僕はこのrotate!メソッドにおける
ローテートの過程を取りたいと思ったんだよ
で次のようなコードを書いてみたんだ
{% highlight ruby %}
 a = [1,2,3]
 3.times.map { a.rotate! }
{% endhighlight %}

そうしたら期待したものとは違う
次のような結果が返ってきたんだ
{% highlight ruby %}
 # => [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
{% endhighlight %}

あれ？
mapがいけないのかな..
{% highlight ruby %}
 q = []
 3.times { q << a.rotate! }
 q # => [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
{% endhighlight %}

ローテートしてないのかと思って
ブロック内でpしてみたらちゃんとしてるんだよ
{% highlight ruby %}
 a = [1,2,3]
 3.times.map { p a.rotate! } # => [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
 # >> [2, 3, 1]
 # >> [3, 1, 2]
 # >> [1, 2, 3]
{% endhighlight %}
なんか変だな..

で少し考えたら理由がわかったんだ
Array#rotate!はselfを返すんだったよ
{% highlight ruby %}
 a = [1,2,3]
 a.object_id # => 2151892940
 3.times.map { a.rotate!.object_id } # => [2151892940, 2151892940, 2151892940]
{% endhighlight %}

つまりmapの返り値はa.rotate!の
スナップショットの配列を返すんじゃなくて
元オブジェクトの参照の配列を返すんだよ
でmapの返り値はすべての要素に対する
イテレートが終わってから返されるから(当然だよね)
その時点つまり最後のa.rotate!の後における
元オブジェクトの状態がすべての配列の要素として
返されることになるんだ

つまりこれは次のコードと同じようなことなんだよ
{% highlight ruby %}
 a = [1,2,3]
 b = a.rotate!
 c = a.rotate!
 d = a.rotate!
 [b, c, d] # => [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
{% endhighlight %}

だからスナップショットつまり途中経過がほしい場合は
さっきみたいにpしたり
to_sしたりdupしたりする必要があるんだね
{% highlight ruby %}
 a = [1,2,3]
 3.times.map { a.rotate!.to_s } # => ["[2, 3, 1]", "[3, 1, 2]", "[1, 2, 3]"]
 a = [1,2,3]
 3.times.map { a.rotate!.dup } # => [[2, 3, 1], [3, 1, 2], [1, 2, 3]]
{% endhighlight %}

同じことはほかのRubyの破壊的メソッドでも起きるよ
{% highlight ruby %}
 s = "hello, world!"
 s.size.times.map { p s.chop! } # => ["", "", "", "", "", "", "", "", "", "", "", "", ""]
 # >> "hello, world"
 # >> "hello, worl"
 # >> "hello, wor"
 # >> "hello, wo"
 # >> "hello, w"
 # >> "hello, "
 # >> "hello,"
 # >> "hello"
 # >> "hell"
 # >> "hel"
 # >> "he"
 # >> "h"
 # >> ""
{% endhighlight %}

うっかりしてるとまたミスしそうだよ
分かってる人には当たり前のことなんだろうけど
僕はちょっと嵌っちゃったから書いてみたよ :)

<del datetime="2011-12-15T07:17:25+09:00">だからビルのエレベーター内での危険行為はもう止めようよ!</del>
だからRubyのエニュメレータ内での破壊行為はもう止めようよ!